




* 微服务
 一种新型架构术语的定义
**  原文信息
*** 作者介绍
- James Lewis
  - James Lewis 是 Thoughtworks 的首席顾问和技术顾问委员会成员。 James 对通过小型协作服务构建应用程序的兴趣源于大规模集成企业系统的背景。他使用微服务构建了许多系统，并且几年来一直是不断壮大的社区的积极参与者。
- Martin Fowler
  - Martin Fowler 是软件开发方面的作家、演说家和大腕。长期以来，他一直对如何将软件系统组件化这一问题感到困惑，听到过比他满意的更多模糊的说法。他希望微服务能够兑现其倡导者所做出的早期承诺。
*** 原文地址
- [[https://martinfowler.com/articles/microservices.html]]
*** 原文发表时间
- 2014.3.25
** 前言
术语“微服务架构”在过去几年中如雨后春笋般涌现，描述了一种将软件应用程序设计为独立可部署服务套件的特定方式。虽然没有对这种架构风格的精确定义，但围绕业务能力、自动化部署、端点智能以及语言和数据的分散控制，组织具有某些共同特征。

“微服务”——软件架构拥挤街道上的又一个新术语。尽管我们的自然倾向是轻蔑地瞥一眼这些东西，但这个术语描述了一种我们发现越来越有吸引力的软件系统风格。在过去的几年里，我们已经看到许多项目使用这种风格，到目前为止，结果是积极的，以至于对于我们的许多同事来说，这正在成为构建企业应用程序的默认风格。然而，令人遗憾的是，没有太多信息概述微服务风格是什么以及如何做到这一点。

简而言之，微服务架构风格 [1] 是一种将单个应用程序开发为一组小型服务的方法，每个服务都在自己的进程中运行并与轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务围绕业务能力构建，可通过全自动部署机制独立部署。这些服务的集中管理是最低限度的，它们可能用不同的编程语言编写，并使用不同的数据存储技术。

要开始解释微服务风格，将其与整体式风格进行比较是很有用的：作为单个单元构建的整体式应用程序。企业应用程序通常由三个主要部分构建： 客户端用户界面（由 HTML 页面和在用户计算机上的浏览器中运行的 javascript 组成） 数据库（由插入到公共且通常是关系数据库管理中的许多表组成）系统）和服务器端应用程序。服务器端应用程序将处理 HTTP 请求、执行域逻辑、从数据库中检索和更新数据，以及选择和填充要发送到浏览器的 HTML 视图。这个服务器端应用程序是一个整体——一个单一的逻辑可执行文件[2]。对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。

这样一个单体服务器是构建这样一个系统的自然方式。处理请求的所有逻辑都在单个进程中运行，允许您使用语言的基本特性将应用程序划分为类、函数和名称空间。小心点，您可以在开发人员的笔记本电脑上运行和测试应用程序，并使用部署管道确保更改得到正确测试并部署到生产环境中。您可以通过在负载均衡器后面运行许多实例来水平扩展单体。

整体式应用程序可以取得成功，但越来越多的人对它们感到沮丧 - 特别是随着越来越多的应用程序被部署到云中。变更周期是紧密联系在一起的——对应用程序的一小部分进行的变更，需要重建和部署整个整体。随着时间的推移，通常很难保持良好的模块化结构，从而更难保持应该只影响该模块中的一个模块的更改。扩展需要扩展整个应用程序，而不是需要更多资源的部分。

[[/home/auto/org/bi_she/y1.png]]
- 图 1：单体和微服务


这些挫折导致了微服务架构风格：将应用程序构建为服务套件。除了服务可独立部署和扩展这一事实外，每个服务还提供了牢固的模块边界，甚至允许使用不同的编程语言编写不同的服务。它们也可以由不同的团队管理。

我们并不声称微服务风格是新颖的或创新的，它的根源至少可以追溯到 Unix 的设计原则。但我们确实认为没有足够多的人考虑微服务架构，如果他们使用它，许多软件开发会更好。

** 微服务架构的特征
我们不能说有微服务架构风格的正式定义，但我们可以尝试描述我们认为符合该标签的架构的共同特征。与任何概述共同特征的定义一样，并非所有微服务架构都具有所有特征，但我们确实希望大多数微服务架构表现出大部分特征。虽然我们的作者一直是这个相当松散的社区的活跃成员，但我们的目的是尝试描述我们在自己的工作中以及我们所知道的团队在类似努力中看到的内容。特别是我们没有制定一些要符合的定义。

** 通过服务进行组件化
自从我们涉足软件行业以来，就一直希望通过将组件插入在一起来构建系统，这与我们在物理世界中看到事物的方式很相似。在过去的几十年里，我们已经看到作为大多数语言平台一部分的大型公共库纲要取得了相当大的进步。

在谈论组件时，我们遇到了关于什么构成组件的困难定义。我们的定义是组件是一个可以独立替换和升级的软件单元。

微服务架构将使用库，但它们将自己的软件组件化的主要方式是分解为服务。我们将库定义为链接到程序中并使用内存中函数调用进行调用的组件，而服务是进程外组件，它们与诸如 Web 服务请求或远程过程调用之类的机制进行通信。 （这与许多 OO 程序 [3] 中的服务对象的概念不同。）

使用服务作为组件（而不是库）的一个主要原因是服务可以独立部署。如果您的应用程序 [4] 在单个进程中包含多个库，则对任何单个组件的更改都会导致必须重新部署整个应用程序。但是，如果该应用程序被分解为多个服务，您可以预期许多单个服务更改只需要重新部署该服务。这不是绝对的，一些变化会改变服务接口，从而导致一些协调，但良好的微服务架构的目标是通过服务契约中的内聚服务边界和演化机制来最小化这些。

将服务用作组件的另一个结果是更明确的组件接口。大多数语言都没有用于定义显式发布接口的良好机制。通常只有文档和纪律可以防止客户破坏组件的封装，从而导致组件之间的耦合过于紧密。通过使用显式远程调用机制，服务可以更轻松地避免这种情况。

使用这样的服务确实有缺点。远程调用比进程内调用更昂贵，因此远程 API 需要更粗粒度，这通常更难使用。如果您需要更改组件之间的职责分配，那么当您跨越流程边界时，这样的行为移动就更难做到。

初步估计，我们可以观察到服务映射到运行时进程，但这只是初步估计。一项服务可能包含多个始终一起开发和部署的进程，例如应用程序进程和仅由该服务使用的数据库。
** 围绕业务能力组织
当希望将大型应用程序拆分成多个部分时，管理层通常会关注技术层，从而导致 UI 团队、服务器端逻辑团队和数据库团队。当团队沿着这些路线分离时，即使是简单的更改也可能导致跨团队项目需要时间和预算批准。一个聪明的团队将围绕这一点进行优化，并在两害相权取其轻 - 只需将逻辑强加到他们有权访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律在实践中的一个例子。

- 任何设计系统（广义定义）的组织都会产生一个设计，其结构是组织通信结构的副本。 ——梅尔文·康威，1968 年

[[/home/auto/org/bi_she/y2.png]]
- 图 2：康威定律的实际应用

微服务的划分方式不同，拆分成围绕业务能力组织的服务。此类服务针对该业务领域采用广泛的软件实现，包括用户界面、持久存储和任何外部协作。因此，团队是跨职能的，包括开发所需的全部技能：用户体验、数据库和项目管理。

[[/home/auto/org/bi_she/y3.png]]
- 图 3：由团队边界强化的服务边界
****  微服务有多大？
尽管“微服务”已成为这种架构风格的流行名称，但不幸的是，它的名称确实导致了对服务规模的关注，以及关于什么是“微”的争论。在我们与微服务从业者的对话中，我们看到了各种规模的服务。报告的最大规模遵循亚马逊的两个比萨团队的概念（即整个团队可以由两个比萨饼喂养），这意味着不超过十几个人。在较小规模的情况下，我们已经看到一个由六个人组成的团队支持六个服务的设置。

这就引出了一个问题，即在这个规模范围内是否存在足够大的差异，以至于不应将每打人服务和每人服务规模归为一个微服务标签。目前我们认为最好将它们组合在一起，但随着我们进一步探索这种风格，我们当然有可能改变主意。

** 产品不是项目
我们看到的大多数应用程序开发工作都使用项目模型：目标是交付一些软件，然后将其视为已完成。完成后，软件将移交给维护组织，构建它的项目团队将解散。

微服务支持者倾向于避免这种模型，而是更喜欢团队应该在产品的整个生命周期内拥有产品的概念。对此的一个共同启发是亚马逊的“你构建，你运行它”的概念，其中开发团队对生产中的软件负全部责任。这使开发人员能够每天了解他们的软件在生产中的行为方式，并增加与用户的联系，因为他们至少必须承担一些支持负担。

产品心态与业务能力相关联。与其将软件视为一组要完成的功能，不如将软件视为一种持续的关系，问题在于软件如何帮助其用户增强业务能力。

没有理由不能对单体应用程序采用同样的方法，但服务的粒度更小可以更容易地在服务开发人员和他们的用户之间建立个人关系。

** 智能端点和哑管道
在不同进程之间构建通信结构时，我们看到许多产品和方法都强调将重要的智慧融入通信机制本身。这方面的一个很好的例子是企业服务总线 (ESB)，其中 ESB 产品通常包括用于消息路由、编排、转换和应用业务规则的复杂设施。

微服务社区倾向于另一种方法：智能端点和哑管道。从微服务构建的应用程序旨在尽可能地解耦和结合——它们拥有自己的域逻辑，并且更多地充当经典 Unix 意义上的过滤器——接收请求、适当地应用逻辑并产生响应。这些是使用简单的 RESTish 协议编排的，而不是复杂的协议，例如 WS-Choreography 或 BPEL 或中央工具编排。

最常用的两种协议是带有资源 API 的 HTTP 请求-响应和轻量级消息传递 [7]。第一个最好的表达是
- 属于网络，而不是网络背后 ——伊恩·罗宾逊

微服务团队使用构建万维网（在很大程度上是 Unix）的原则和协议。开发人员或操作人员只需很少的努力就可以缓存经常使用的资源。

第二种常用方法是通过轻量级消息总线进行消息传递。选择的基础设施通常是愚蠢的（愚蠢的，因为仅作为消息路由器） - 简单的实现，如 RabbitMQ 或 ZeroMQ，除了提供可靠的异步结构之外，所做的不多 - 智能仍然存在于生产和生产的端点消费消息；在服务中。

在单体中，组件在进程内执行，它们之间的通信通过方法调用或函数调用进行。将单体应用改成微服务的最大问题在于改变通信模式。从内存中方法调用到 RPC 的简单转换会导致性能不佳的冗长通信。相反，您需要用粗粒度的方法替换细粒度的通信。
** 去中心化治理
集中治理的后果之一是倾向于在单一技术平台上进行标准化。经验表明，这种方法是有局限性的——不是每个问题都是钉子，也不是每个解决方案都是锤子。我们更喜欢使用正确的工具来完成工作，虽然单体应用程序可以在一定程度上利用不同的语言，但这并不常见。

将单体的组件拆分为服务，我们在构建每个组件时都可以选择。您想使用 Node.js 建立一个简单的报告页面吗？大胆试试吧。用于特别粗糙的近实时组件的 C++？美好的。您想要交换一种更适合一个组件读取行为的不同风格的数据库吗？我们拥有重建他的技术。

当然，仅仅因为你可以做某事，并不意味着你应该做——但以这种方式对你的系统进行分区意味着你有选择权。

构建微服务的团队也更喜欢采用不同的标准方法。与其使用写在纸上某处的一组已定义标准，他们更喜欢生产有用工具的想法，其他开发人员可以使用这些工具来解决与他们面临的类似问题。这些工具通常是从实施中收获的，并与更广泛的群体共享，有时但不完全使用内部开源模型。现在 git 和 github 已经成为事实上的首选版本控制系统，开源实践在内部变得越来越普遍。

Netflix 是遵循这一理念的组织的一个很好的例子。将有用的，最重要的是，作为库共享经过实战检验的代码鼓励其他开发人员以类似的方式解决类似的问题，但如果需要，则可以选择不同的方法。共享库倾向于关注数据存储、进程间通信以及我们在下面进一步讨论的基础设施自动化等常见问题。

对于微服务社区，开销特别没有吸引力。这并不是说社区不重视服务合同。恰恰相反，因为它们往往更多。只是他们正在寻找管理这些合同的不同方式。 Tolerant Reader 和 Consumer-Driven Contracts 等模式通常应用于微服务。这些帮助服务合同独立发展。执行消费者驱动的合同作为构建的一部分可以增加信心，并提供有关您的服务是否正常运行的快速反馈。事实上，我们知道澳大利亚的一个团队通过消费者驱动的合同来推动新服务的构建。他们使用允许他们定义服务契约的简单工具。在为新服务编写代码之前，这成为自动构建的一部分。然后仅在满足合同的情况下构建服务——这是一种在构建新软件时避免“YAGNI”[8] 困境的优雅方法。这些技术和围绕它们发展起来的工具通过减少服务之间的时间耦合来限制对中央合同管理的需求。

也许去中心化治理的最高点是亚马逊推广的构建/运行精神。团队负责他们构建的软件的所有方面，包括 24/7 全天候运行软件。这种级别的责任下放绝对不是常态，但我们确实看到越来越多的公司将责任推给开发团队。 Netflix 是另一个采用这种精神的组织[10]。每晚凌晨 3 点被寻呼机叫醒无疑是编写代码时关注质量的强大动力。这些想法与传统的中心化治理模式相去甚远。

*** 多种语言，多种选择
JVM 作为一个平台的发展只是在一个通用平台中混合语言的最新例子。几十年来，通常的做法是使用更高级别的语言来利用更高级别的抽象。正如深入研究并在较低级别编写对性能敏感的代码一样。然而，许多单体不需要这种级别的性能优化，DSL 和更高级别的抽象也不需要（令我们沮丧的是）。相反，单体通常是单一语言，并且倾向于限制使用的技术数量 [9]。
*** 久经考验的标准和强制执行的标准
微服务团队倾向于避开企业架构团队制定的那种严格执行的标准，但会乐于使用甚至传播开放标准（如 HTTP、ATOM 和其他微格式）的使用，这有点矛盾。

关键区别在于标准的制定方式和执行方式。由 IETF 等团体管理的标准只有在更广泛的世界中有多个实时实施并且通常来自成功的开源项目时才会成为标准。

这些标准与企业界中的许多标准截然不同，这些标准通常是由最近很少有编程经验或受供应商过度影响的团体开发的。
** 分散的数据管理
数据管理的分散化以多种不同的方式呈现。在最抽象的层面上，这意味着世界的概念模型会因系统而异。这是跨大型企业集成时的常见问题，客户的销售视图与支持视图不同。一些在销售视图中称为客户的东西可能根本不会出现在支持视图中。那些这样做的可能具有不同的属性和（更糟糕的）具有细微不同语义的共同属性。

此问题在应用程序之间很常见，但也可能发生在应用程序内部，尤其是当该应用程序被划分为单独的组件时。一个有用的思考方式是限界上下文的领域驱动设计概念。 DDD 将一个复杂的领域划分为多个有界上下文，并映射出它们之间的关系。此过程对整体架构和微服务架构都很有用，但服务和上下文边界之间存在自然关联，有助于澄清，并且正如我们在业务功能部分中描述的那样，加强了分离。

除了分散有关概念模型的决策外，微服务还分散了数据存储决策。虽然整体应用程序更喜欢单一逻辑数据库来存储持久数据，但企业通常更喜欢跨一系列应用程序的单一数据库——其中许多决策是由供应商围绕许可的商业模型驱动的。微服务更喜欢让每个服务管理自己的数据库，可以是同一数据库技术的不同实例，也可以是完全不同的数据库系统——一种称为 Polyglot Persistence 的方法。您可以在整体中使用多语言持久性，但它在微服务中出现得更频繁。

[[/home/auto/org/bi_she/y4.png]]
- 图 4 ： 单数据源 多数据源

跨微服务分散数据责任对管理更新有影响。处理更新的常用方法是使用事务来保证更新多个资源时的一致性。这种方法通常在单体应用中使用。

使用这样的事务有助于一致性，但会强加显着的时间耦合，这在多个服务之间是有问题的。众所周知，分布式事务难以实现，因此微服务架构强调服务之间的无事务协调，并明确认识到一致性可能只是最终一致性，问题通过补偿操作来处理。

选择以这种方式管理不一致对许多开发团队来说是一个新的挑战，但它通常与业务实践相匹配。企业通常会处理一定程度的不一致，以便快速响应需求，同时采用某种逆向流程来处理错误。只要纠正错误的成本低于在更高一致性下失去业务的成本，这种权衡是值得的。

** 基础设施自动化
基础设施自动化技术在过去几年中发生了巨大的变化——云的发展，尤其是 AWS 的发展降低了构建、部署和运行微服务的操作复杂性。

许多使用微服务构建的产品或系统都是由在持续交付及其前身持续集成方面具有丰富经验的团队构建的。以这种方式构建软件的团队广泛使用了基础设施自动化技术。这在下面显示的构建管道中进行了说明。

[[/home/auto/org/bi_she/y5.png]]
- 图 5：基本构建管道

由于这不是一篇关于持续交付的文章，我们将在这里提醒大家注意几个关键特性。我们希望尽可能多地确信我们的软件正在运行，因此我们运行了大量的自动化测试。将工作软件“提升”到管道意味着我们可以自动部署到每个新环境。

将非常愉快地在这些环境中构建、测试和推送单体应用程序。事实证明，一旦您投资于自动化单体应用的生产路径，那么部署更多应用程序似乎就不再那么可怕了。请记住，CD 的目标之一是让部署变得乏味，因此无论是一个还是三个应用程序，只要它仍然乏味就没有关系[11]。

我们看到团队使用广泛的基础设施自动化的另一个领域是在生产中管理微服务。与我们上面的断言相反，只要部署很无聊，单体和微服务之间就没有太大区别，两者的操作环境可能截然不同。

[[/home/auto/org/bi_she/y6.png]]
- 图 6：模块部署通常不同

** 失败设计
将服务用作组件的结果是，应用程序需要设计为能够容忍服务失败。由于供应商不可用，任何服务调用都可能失败，客户必须尽可能优雅地对此做出响应。与单片设计相比，这是一个缺点，因为它引入了额外的复杂性来处理它。结果是微服务团队不断反思服务故障如何影响用户体验。 Netflix 的 Simian Army 在工作日期间引发服务甚至数据中心的故障，以测试应用程序的弹性和监控。


这种生产中的自动化测试足以让大多数运营团队在下班前通常会感到不寒而栗。这并不是说单一的架构风格不能进行复杂的监控设置——它只是在我们的经验中不太常见。

由于服务随时可能失败，因此能够快速检测到故障并在可能的情况下自动恢复服务非常重要。微服务应用程序非常重视应用程序的实时监控，检查架构元素（数据库每秒收到多少请求）和业务相关指标（例如每分钟收到多少订单）。语义监控可以提供出现问题的早期预警系统，触发开发团队跟进和调查。

这对于微服务架构尤为重要，因为微服务对编排和事件协作的偏好会导致紧急行为。虽然许多权威人士称赞意外出现的价值，但事实是，突发行为有时可能是一件坏事。监控对于快速发现不良的紧急行为至关重要，以便可以修复它。

Monoliths 可以构建得像微服务一样透明——事实上，它们应该如此。不同之处在于，您绝对需要知道在不同进程中运行的服务何时断开连接。对于同一流程中的库，这种透明度不太可能有用。

微服务团队希望看到针对每个单独服务的复杂监控和日志记录设置，例如显示上/下状态的仪表板以及各种操作和业务相关指标。有关断路器状态、当前吞吐量和延迟的详细信息是我们在野外经常遇到的其他示例。

** 进化设计
微服务从业者通常具有进化设计背景，并将服务分解视为一种进一步的工具，使应用程序开发人员能够在不减慢更改速度的情况下控制其应用程序中的更改。变更控制并不一定意味着减少变更——只要有正确的态度和工具，您就可以对软件进行频繁、快速且控制良好的变更。

每当您尝试将软件系统分解成组件时，您都会面临如何划分各个部分的决定 - 我们决定将应用程序分割的原则是什么？组件的关键属性是独立替换和可升级性的概念[12]——这意味着我们寻找可以想象重写组件而不影响其协作者的点。事实上，许多微服务团队通过明确期望许多服务被废弃而不是在长期内发展来更进一步。

卫报网站是应用程序的一个很好的例子，它被设计和构建为一个整体，但一直在向微服务方向发展。单体仍然是网站的核心，但他们更喜欢通过构建使用单体 API 的微服务来添加新功能。这种方法对于本质上是临时的功能特别方便，例如处理体育赛事的专门页面。网站的这一部分可以使用快速开发语言快速组合在一起，并在活动结束后删除。我们在一家金融机构看到了类似的方法，在这些机构中，为市场机会添加新服务并在几个月甚至几周后丢弃。

这种对可替换性的强调是模块化设计更普遍原则的一个特例，即通过变化模式来驱动模块化 [13]。您希望将同时更改的内容保存在同一个模块中。系统中很少更改的部分应该与那些目前正在经历大量变动的服务不同。如果您发现自己反复同时更改两个服务，则表明它们应该合并。

将组件投入服务增加了更精细的发布计划的机会。对于单体，任何更改都需要完整构建和部署整个应用程序。然而，对于微服务，您只需要重新部署您修改的服务。这可以简化和加快发布过程。缺点是您必须担心对一项服务的更改会破坏其消费者。传统的集成方法是尝试使用版本控制来处理这个问题，但微服务世界的偏好是仅将版本控制作为最后的手段。我们可以通过将服务设计为尽可能容忍其供应商的变化来避免大量版本控制。

** 微服务是未来吗？
我们写这篇文章的主要目的是解释微服务的主要思想和原理。通过花时间做这件事，我们清楚地认为微服务架构风格是一个重要的想法——一个值得企业应用程序认真考虑的想法。我们最近使用这种风格构建了几个系统，并且知道其他人使用并喜欢这种方法。

我们所知道的在某种程度上引领建筑风格的人包括亚马逊、Netflix、卫报、英国政府数字服务、realestate.com.au、Forward 和 comparethemarket.com。 2013 年的巡回会议充满了公司转向微服务的例子——包括 Travis CI。此外，还有许多组织长期以来一直在做我们称之为微服务的事情，但从未使用过这个名称。 （通常这被标记为 SOA - 尽管正如我们所说，SOA 有许多相互矛盾的形式。[14]）

然而，尽管有这些积极的经验，我们并不是说我们确定微服务是软件架构的未来方向。虽然我们到目前为止的经验与整体应用程序相比是积极的，但我们意识到我们还没有足够的时间来做出全面的判断。

通常，您的架构决策的真正后果只有在您做出这些决策后几年才会显现出来。我们已经看到一些项目，在这些项目中，一个优秀的团队对模块化有着强烈的渴望，他们构建了一个多年来已经衰败的单体架构。许多人认为微服务不太可能出现这种衰退，因为服务边界是明确的并且难以修补。然而，在我们看到足够多的系统具有足够的年龄之前，我们无法真正评估微服务架构的成熟程度。

人们可能期望微服务成熟度不高当然是有原因的。在组件化的任何努力中，成功取决于软件与组件的匹配程度。很难确定组件边界的确切位置。演进式设计认识到获得正确边界的困难，因此认识到易于重构它们的重要性。但是，当您的组件是具有远程通信的服务时，重构比使用进程内库要困难得多。跨服务边界移动代码很困难，任何接口更改都需要在参与者之间进行协调，需要添加向后兼容性层，并且测试变得更加复杂。

另一个问题是如果组件没有干净地组合，那么您所做的就是将复杂性从组件内部转移到组件之间的连接上。这不仅会转移复杂性，还会将其转移到不太明确且更难控制的地方。当您查看一个小而简单的组件的内部时，很容易认为事情会更好，同时忽略服务之间的混乱连接。

最后，还有团队技能的因素。新技术往往被更熟练的团队采用。但是，对技能较高的团队更有效的技术不一定适用于技能较低的团队。我们已经看到很多技术欠佳的团队构建杂乱无章的单体架构的案例，但需要时间来了解当微服务出现这种混乱时会发生什么。一个糟糕的团队总是会创建一个糟糕的系统——很难说微服务在这种情况下是减少了混乱还是使情况变得更糟。

我们听到的一个合理论点是，您不应该从微服务架构开始。取而代之的是从单体开始，保持模块化，一旦单体成为问题，就将其拆分为微服务。 （虽然这个建议并不理想，因为一个好的进程内接口通常不是一个好的服务接口。）

因此，我们以谨慎乐观的态度写下这篇文章。到目前为止，我们已经对微服务风格有了足够多的了解，觉得它是一条值得走的路。我们不能肯定地说我们会在哪里结束，但软件开发的挑战之一是您只能根据您当前必须掌握的不完美信息做出决策。
** 脚注
1：2011 年 5 月在威尼斯附近的软件架构师研讨会上讨论了术语“微服务”，以描述与会者所看到的一种常见的架构风格，他们中的许多人最近一直在探索这种风格。 2012 年 5 月，同一小组决定将“微服务”作为最合适的名称。 2012 年 3 月，James 在 Krakow 的第 33 届微服务专业 - Java，Unix Way 上将其中一些想法作为案例研究进行了介绍，Fred George 大约在同一时间进行了介绍。 Netflix 的 Adrian Cockcroft 将这种方法描述为“细粒度 SOA”，在 Web 规模上开创了这种风格，本文中提到的许多其他人也是如此——Joe Walnes、Daniel Terhorst-North、Evan Botcher 和 Graham Tackley。

2：Unix 社区使用单体一词已经有一段时间了。它出现在 The Art of Unix Programming 中，用来描述变得太大的系统。

3：许多面向对象的设计者，包括我们自己，在领域驱动设计的意义上使用术语服务对象来表示执行与实体无关的重要过程的对象。这与我们在本文中使用“服务”的方式不同。遗憾的是，服务一词具有两种含义，我们不得不忍受多义词。

4：我们认为应用程序是一种社会结构，它将代码库、功能组和资金主体结合在一起。

5：我们不得不提到 Jim Webber 的说法，即 ESB 代表“Erroneous Spaghetti Box”。

6：Netflix 使链接变得明确——直到最近将他们的架构风格称为细粒度 SOA。

7：在极端规模下，组织通常会转向二进制协议——例如 protobufs。使用这些的系统仍然表现出智能端点、哑管道的特征——并以透明度换取规模。大多数网络资产，当然还有绝大多数企业不需要做出这种权衡——透明度可能是一个巨大的胜利。

8：“YAGNI”或“你不会需要它”是一个 XP 原则和告诫，在你知道你需要它们之前不要添加特性。

9：我们声称单体应用是单一语言有点不真诚——为了在当今的网络上构建系统，您可能需要了解 JavaScript 和 XHTML、CSS、您选择的服务器端语言、SQL 和 ORM 方言。几乎没有单一的语言，但你知道我们的意思。

10：Adrian Cockcroft 在 2013 年 11 月于 Flowcon 发表的精彩演讲中特别提到了“开发者自助服务”和“开发者运行他们编写的内容”（原文如此）。

11：我们在这里有点不真诚显然，在更复杂的拓扑结构中部署更多服务比部署单个单体更困难。幸运的是，模式降低了这种复杂性——尽管对工具的投资仍然是必须的。

12：事实上，Daniel Terhorst-North 将这种风格称为可替换组件架构，而不是微服务。由于这似乎与我们更喜欢后者的特征的子集有关。

13：Kent Beck 强调这是他在实现模式中的设计原则之一。

14：SOA 并不是这段历史的根源。我记得当 SOA 术语出现在本世纪初时，人们说“我们已经这样做多年了”。一种说法是，这种风格将其根源视为 COBOL 程序在企业计算的早期通过数据文件进行通信的方式。在另一个方向上，人们可能会争辩说微服务与 Erlang 编程模型是一回事，但适用于企业应用程序上下文。

** 参考
虽然这不是一个详尽的清单，但从业者可以从许多来源中汲取灵感，或者支持与本文中描述的理念类似的理念。

博客和在线文章:
- Clemens Vasters 在微软云上的博客
- David Morgantini 在他的博客上对该主题的介绍
- 来自 Heroku 的 12 要素应用程序
- 英国政府数字服务设计原则
- Alistair Cockburn 谈六角形建筑

books:
- Release it
- Rest in practice
- Enterprise Integration Patterns
- unix编程艺术
- 在测试的指导下发展面向对象的软件
- 现代企业：绩效和增长的组织设计
- 持续交付：通过构建、测试和部署自动化实现可靠的软件发布
- 领域驱动设计：解决软件核心的复杂性
